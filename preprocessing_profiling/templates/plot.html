<script>
	function plotSankey(data, svg) {
		require(['d3', 'sankey'], function(d3, d3sankey){
			var tooltip = d3.select("body")
				.append("div")
				.style("position", "absolute")
				.style("z-index", "10")
				.style("visibility", "hidden")
				.style("background-color", "white")
				.style("border-radius", "3px")
				.style("border-style", "solid")
				.style("border-color", "black")
				.style("border-width", "thin")
				.style("padding", "2px");
			
			var margin = {left: 80, right: 80};
			var height = 300;
			var width = 400;
			var nodeWidth = 5;
			var nodePadding = 20;
			var sankey = d3sankey.sankey()
				.extent([[nodePadding/2 + margin.left, nodePadding/2], [width + margin.left - nodePadding/2, height - nodePadding/2]])
				.nodeWidth(nodeWidth)
				.nodePadding(nodePadding)
				.nodeSort(null);
			
			svg.attr("height", height)
				.attr("width", width + margin.left + margin.right);
			
			svg.append("rect")
				.attr("x", nodePadding/4 + margin.left)
				.attr("y", nodePadding/4)
				.attr("width", nodeWidth + nodePadding/2)
				.attr("height", height - nodePadding/2)
				.attr("fill", "#ddd");
			svg.append("rect")
				.attr("x", width + margin.left - nodeWidth - nodePadding*0.75)
				.attr("y", nodePadding/4)
				.attr("width", nodeWidth + nodePadding/2)
				.attr("height", height - nodePadding/2)
				.attr("fill", "#ddd");
			svg.append("text")
				.attr("text-anchor", "middle")
				.attr("x", nodePadding/4 + margin.left + (nodeWidth + nodePadding/2)/2)
				.attr("y", height)
				.attr("font-family", "sans-serif")
				.attr("font-size", "10px")
				.text("Actual");
			svg.append("text")
				.attr("text-anchor", "middle")
				.attr("x", width + margin.left - nodeWidth - nodePadding*0.75 + (nodeWidth + nodePadding/2)/2)
				.attr("y", height)
				.attr("font-family", "sans-serif")
				.attr("font-size", "10px")
				.text("Predicted");
			
			data = sankey(data);
			
			var nodes = data.nodes;
			var links = data.links;
			
			svg.append("g")
				.attr("stroke", "#000")
				.selectAll("rect")
				.data(nodes)
				.enter()
				.append("rect")
				.attr("x", d => d.x0)
				.attr("y", d => d.y0)
				.attr("height", d => d.y1 - d.y0)
				.attr("width", d => d.x1 - d.x0)
				.attr("fill", d => "#777")
				.append("title")
				.text(d => `${d.name}\n${d.value}`);

			const link = svg.append("g")
				.attr("fill", "none")
				.attr("stroke-opacity", 0.5)
				.selectAll("g")
				.data(links)
				.enter()
				.append("g")
				.style("mix-blend-mode", "multiply");

			var edgeColor = "none";
			
			svg.append("g")
				.selectAll("text")
				.data(links)
				.enter()
				.append("text")
				.text(d => parseFloat(((d.value / d.source.value) * 100).toFixed(2)) + "%")
				.attr("x", d => margin.left + nodePadding + nodeWidth)
				.attr("y", d => d.y0 + 5)
				.attr("font-size", 10)
				.attr("font-family", "sans-serif");
			svg.append("g")
				.selectAll("text")
				.data(links)
				.enter()
				.append("text")
				.attr("text-anchor", "end")
				.text(d => parseFloat(((d.value / d.target.value) * 100).toFixed(2)) + "%")
				.attr("x", d => margin.left + width - nodePadding - nodeWidth)
				.attr("y", d => d.y1 + 5)
				.attr("font-size", 10)
				.attr("font-family", "sans-serif");
			
			link.append("path")
				.attr("d", d3sankey.sankeyLinkHorizontal())
				.attr("stroke", function(d) {
					if(d.target.name === d.source.name) {
						return "#1565c0";
					}
					return "#e6ac00";
				})
				.attr("stroke-width", d => Math.max(1, d.width));

			link.append("title")
				.text(d => `${d.source.name} → ${d.target.name}\n${d.value}`);

			svg.append("g")
				.style("font", "10px sans-serif")
				.selectAll("text")
				.data(nodes)
				.enter()
				.append("text")
				.attr("x", d => d.x0 < width / 2 ? d.x1 - nodeWidth - nodePadding/2 : d.x0 + nodeWidth + nodePadding/2)
				.attr("y", d => (d.y1 + d.y0) / 2)
				.attr("dy", "0.35em")
				.attr("text-anchor", d => d.x0 < width / 2 ? "end" : "start")
				.text(d => d.name);
		});
	}
		
	function plotMultiSankey(data, svg) {
		require(['d3', 'sankey'], function(d3, d3sankey){
			var tooltip = d3.select("body")
				.append("div")
				.style("position", "absolute")
				.style("z-index", "10")
				.style("visibility", "hidden")
				.style("background-color", "white")
				.style("border-radius", "3px")
				.style("border-style", "solid")
				.style("border-color", "black")
				.style("border-width", "thin")
				.style("padding", "2px");
			var margin = {left: 55, right: 40};
			var height = 150;
			var width = 100;
			var nodeWidth = 5;
			var nodePadding = 10;
			var sankeyPadding = 10;
			var all = svg.append("g")
			var diagram = all.append("g");
			var scale = 1.2
			
			diagram.append("rect")
				.attr("x", nodePadding/4)
				.attr("y", nodePadding/4)
				.attr("width", nodeWidth + nodePadding/2)
				.attr("height", height * data.length - nodePadding/2)
				.attr("fill", "#ddd");
			
			for(let i = 0; i < data.length; i++) {
				diagram.append("rect")
					.attr("x", width - nodeWidth - nodePadding*0.75)
					.attr("y", height * i + nodePadding/4)
					.attr("width", nodeWidth + nodePadding/2)
					.attr("height", height - nodePadding/2)
					.attr("fill", "#ddd");
				all.append("text")
					.text(data[i].strategy)
					.attr("x", height * (i + 0.5))
					.attr("y", margin.right + width + 25)
					.attr("font-size", 10)
					.attr("font-family", "sans-serif")
					.attr("text-anchor", "middle");
				
				var sankey = d3sankey.sankey()
					.extent([[nodePadding/2, nodePadding/2 + height * i + sankeyPadding], [width - nodePadding/2, height * (i + 1) - nodePadding/2 - sankeyPadding]])
					.nodeWidth(nodeWidth)
					.nodePadding(nodePadding)
					.nodeSort(null);
				data[i] = sankey(data[i]);
				var nodes = data[i].nodes;
				var links = data[i].links;
				
				diagram.append("g")
					.attr("stroke", "#000")
					.selectAll("rect")
					.data(nodes)
					.enter()
					.append("rect")
					.attr("x", d => d.x0)
					.attr("y", d => d.y0)
					.attr("height", d => d.y1 - d.y0)
					.attr("width", d => d.x1 - d.x0)
					.attr("fill", d => "#777")
					.on("mouseover", d => tooltip.style("visibility", "visible").html(d.name+"<br/>"+d.value))
					.on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
					.on("mouseout", function(){return tooltip.style("visibility", "hidden");});
				
				all.append("g")
					.selectAll("text")
					.data(nodes)
					.enter()
					.append("text")
					.text(function(d) {if(d.name.length > 4){return d.name.substr(0, 3) + ".";}else{return d.name;}})
					.attr("x", d => ((d.y0 + d.y1)/2))
					.attr("y", function(d) {if(d.targetLinks.length != 0){return margin.right + width + 6}else{return margin.right - 1}})
					.attr("font-size", 10)
					.attr("font-family", "sans-serif")
					.attr("text-anchor", "middle")
					.on("mouseover", d => tooltip.style("visibility", "visible").html(d.name+"<br/>"+d.value))
					.on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
					.on("mouseout", function(){return tooltip.style("visibility", "hidden");});
				
				var link = diagram.append("g")
					.attr("fill", "none")
					.attr("stroke-opacity", 0.5)
					.selectAll("g")
					.data(links)
					.enter()
					.append("g")
					.style("mix-blend-mode", "multiply");
				link.append("path")
					.attr("d", d3sankey.sankeyLinkHorizontal())
					.attr("stroke", function(d) {
						if(d.target.name === d.source.name) {
							return "#1565c0";
						}
						return "#e6ac00";
					})
					.attr("stroke-width", d => Math.max(1, d.width));
				link.on("mouseover", d => tooltip.style("visibility", "visible").html(d.source.name+" → "+d.target.name+"<br/>"+parseFloat(((d.value / d.source.value) * 100).toFixed(2))+"%"))
					.on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+20)+"px");})
					.on("mouseout", function(){return tooltip.style("visibility", "hidden");})
					.on("click", function(d) {d3.selectAll("#classFlow"+id+" table").style("display", "none");d3.select("#table"+d.source.index+"-"+d.target.index+"-"+i+"-"+id).style("display", "block");});
			}
			
			all.append("text")
				.text("Actual Class")
				.attr("x", (height * data.length)/2)
				.attr("y", 20)
				.attr("font-size", 10)
				.attr("font-family", "sans-serif")
				.attr("text-anchor", "middle")
				.attr("font-weight", "bold");
			all.append("text")
				.text("Predicted Class")
				.attr("x", (height * data.length)/2)
				.attr("y", margin.right + width + margin.left - 6)
				.attr("font-size", 10)
				.attr("font-family", "sans-serif")
				.attr("text-anchor", "middle")
				.attr("font-weight", "bold");
			
			diagram.attr("transform", "scale(-1, 1) translate(0 "+margin.right+") rotate(90)");
			all.attr("transform", "translate(0 20) scale("+scale+", "+scale+")");
			
			svg.attr("width", (height * data.length) * scale)
				.attr("height", (width + margin.left + margin.right) * scale + 20);
		});
	}
</script>